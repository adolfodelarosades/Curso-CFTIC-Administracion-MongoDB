# Jueves 06/02/2020

## Uso y rendimiento índices 

### Uso del índice

* El orden de los campos en la consulta no influye (por que Mongo parsea la consulta para colocarla de acuerdo al orden del índice)
* Para que la consulta use el índice debe contener campos que estén en los prefijos delimitados por el índice.
* Si tiene el primer campo, siempre usara el índice (la eficiencia ya es otra cosa)

### Elección del índice en caso de que varios índices se puedan utilizar.

* **Query Optimizer** que evalua para una determinada "forma" de la consulta cual de los índices es el más eficiente.
* Vuelca los planes ganadores en **Plan Cache**.

Podemos monitorizar los índices para saber cuales son los más usados y borrar los que menos se usen.

### Uso de los índices en las consultas ordenadas

Como se distribuye el uso de los recursos en MongoDB

Memoria Ram

* Indices 
* dataset "fuente de datos"

Disco Duro

* Datos almacenados

En el disco busco los datos que haga la consulta y la ordenación la hace en la RAM y es muy costoso, hay limete de 32 MB para ordenar.

¿Qué pasa si el orden del índice coincide con el orden de consulta? **Es más rápido** y se consume menos RAM.

**Tratar para las consultas ordenadas un índice**

Para crear la BD maraton
```js
db = db.getSiblingDB("maraton");

let nombres = ["Carlos", "Lucía", "Juan", "María"];
let apellidos = ["Rodríguez", "López", "Gómez", "García"];
let letras = ["A","C","F","U","J","K", "P"];
let participantes = [];

for( i=0; i < 1000000; i++){
    participantes.push({
        nombre: nombres[Math.floor(Math.random()* nombres.length)],
        apellidos1: apellidos[Math.floor(Math.random()* apellidos.length)],
        apellidos2: apellidos[Math.floor(Math.random()* apellidos.length)],
        edad: Math.floor(Math.random()*100),
        dni: Math.floor(Math.random() * 100000000) + letras[Math.floor(Math.random() * letras.length)]
    });
}

db.participantes.insert(participantes);
```

```sh
> use maraton
switched to db maraton
> db.participantes.dropIndexes()
{
        "nIndexesWas" : 1,
        "msg" : "non-_id indexes dropped for collection",
        "ok" : 1
}
>

```

1. Ordenación sin índices limite 32 MB

   Realizará la ordenación en memoría con límite.

```sh
> db.participantes.find().sort({apellido1: 1}).explain("allPlansExecution")
{
        "queryPlanner" : {
                "plannerVersion" : 1,
                "namespace" : "maraton.participantes",
                "indexFilterSet" : false,
                "parsedQuery" : {

                },
                "winningPlan" : {
                        "stage" : "SORT",
                        "sortPattern" : {
                                "apellido1" : 1
                        },
                        "inputStage" : {
                                "stage" : "SORT_KEY_GENERATOR",
                                "inputStage" : {
                                        "stage" : "COLLSCAN",
                                        "direction" : "forward"
                                }
                        }
                },
                "rejectedPlans" : [ ]
        },
        "executionStats" : {
                "executionSuccess" : false,
                "errorMessage" : "Exec error resulting in state FAILURE :: caused by :: Sort operation used more than the maximum 33554432 bytes of RAM. Add an index, or specify a smaller limit.",
                "errorCode" : 96,
                "nReturned" : 0,
                "executionTimeMillis" : 674,
                "totalKeysExamined" : 0,
                "totalDocsExamined" : 258348,
                "executionStages" : {
                        "stage" : "SORT",
                        "nReturned" : 0,
                        "executionTimeMillisEstimate" : 206,
                        "works" : 258351,
                        "advanced" : 0,
                        "needTime" : 258350,
                        "needYield" : 0,
                        "saveState" : 2021,
                        "restoreState" : 2021,
                        "isEOF" : 0,
                        "sortPattern" : {
                                "apellido1" : 1
                        },
                        "memUsage" : 33554508,
                        "memLimit" : 33554432,
                        "inputStage" : {
                                "stage" : "SORT_KEY_GENERATOR",
                                "nReturned" : 258348,
                                "executionTimeMillisEstimate" : 197,
                                "works" : 258350,
                                "advanced" : 258348,
                                "needTime" : 2,
                                "needYield" : 0,
                                "saveState" : 2021,
                                "restoreState" : 2021,
                                "isEOF" : 0,
                                "inputStage" : {
                                        "stage" : "COLLSCAN",
                                        "nReturned" : 258348,
                                        "executionTimeMillisEstimate" : 192,
                                        "works" : 258349,
                                        "advanced" : 258348,
                                        "needTime" : 1,
                                        "needYield" : 0,
                                        "saveState" : 2021,
                                        "restoreState" : 2021,
                                        "isEOF" : 0,
                                        "direction" : "forward",
                                        "docsExamined" : 258348
                                }
                        }
                },
                "allPlansExecution" : [ ]
        },
        "serverInfo" : {
                "host" : "G24-EQ09",
                "port" : 27017,
                "version" : "4.2.2",
                "gitVersion" : "a0bbbff6ada159e19298d37946ac8dc4b497eadf"
        },
        "ok" : 1
}
>         
```
Me marca el error que indica que nos estamos pasando de los 32 MB y no lo puede ordenar.

Si queremos saltarnos esto será imprecindible tener un índice así ayudamos a la RAM.

Si ejecuto solo la consulta tambén da error:

```sh
> db.participantes.find().sort({apellido1: 1})
Error: error: {
        "ok" : 0,
        "errmsg" : "Executor error during find command :: caused by :: Sort operation used more than the maximum 33554432 bytes of RAM. Add an index, or specify a smaller limit.",
        "code" : 96,
        "codeName" : "OperationFailed"
}
>      
```

Si limitamos la consulta lo ejecutará, por que usa menos registros y por lo tanto menos RAM.

```sh
> db.participantes.find({apellido1:/^L/}).sort({apellido1: 1}).explain("allPlansExecution")
{
        "queryPlanner" : {
                "plannerVersion" : 1,
                "namespace" : "maraton.participantes",
                "indexFilterSet" : false,
                "parsedQuery" : {
                        "apellido1" : {
                                "$regex" : "^L"
                        }
                },
                "winningPlan" : {
                        "stage" : "SORT",
                        "sortPattern" : {
                                "apellido1" : 1
                        },
                        "inputStage" : {
                                "stage" : "SORT_KEY_GENERATOR",
                                "inputStage" : {
                                        "stage" : "COLLSCAN",
                                        "filter" : {
                                                "apellido1" : {
                                                        "$regex" : "^L"
                                                }
                                        },
                                        "direction" : "forward"
                                }
                        }
                },
                "rejectedPlans" : [ ]
        },
        "executionStats" : {
                "executionSuccess" : true,
                "nReturned" : 0,
                "executionTimeMillis" : 821,
                "totalKeysExamined" : 0,
                "totalDocsExamined" : 1000000,
                "executionStages" : {
                        "stage" : "SORT",
                        "nReturned" : 0,
                        "executionTimeMillisEstimate" : 210,
                        "works" : 1000004,
                        "advanced" : 0,
                        "needTime" : 1000003,
                        "needYield" : 0,
                        "saveState" : 7816,
                        "restoreState" : 7816,
                        "isEOF" : 1,
                        "sortPattern" : {
                                "apellido1" : 1
                        },
                        "memUsage" : 0,
                        "memLimit" : 33554432,
                        "inputStage" : {
                                "stage" : "SORT_KEY_GENERATOR",
                                "nReturned" : 0,
                                "executionTimeMillisEstimate" : 210,
                                "works" : 1000003,
                                "advanced" : 0,
                                "needTime" : 1000002,
                                "needYield" : 0,
                                "saveState" : 7816,
                                "restoreState" : 7816,
                                "isEOF" : 1,
                                "inputStage" : {
                                        "stage" : "COLLSCAN",
                                        "filter" : {
                                                "apellido1" : {
                                                        "$regex" : "^L"
                                                }
                                        },
                                        "nReturned" : 0,
                                        "executionTimeMillisEstimate" : 210,
                                        "works" : 1000002,
                                        "advanced" : 0,
                                        "needTime" : 1000001,
                                        "needYield" : 0,
                                        "saveState" : 7816,
                                        "restoreState" : 7816,
                                        "isEOF" : 1,
                                        "direction" : "forward",
                                        "docsExamined" : 1000000
                                }
                        }
                },
                "allPlansExecution" : [ ]
        },
        "serverInfo" : {
                "host" : "G24-EQ09",
                "port" : 27017,
                "version" : "4.2.2",
                "gitVersion" : "a0bbbff6ada159e19298d37946ac8dc4b497eadf"
        },
        "ok" : 1
}
>      
```

### Motores de Almacenamiento:

* Wired Tiger
* In-memory

MongoDB vende un sistema de InMemory que va todo en la memoria, en disco sólo los Backups, es muy caro pero muy rápido.

### Vizualizando el explain()

Viendo el explain() con Koda:

<img src="/images/koda1.png">

Viendo el explain() con Compass:

<img src="/images/compass.png">

Viendo el explain() con la Shell:

```sh
> db.participantes.find({apellido1:"López"}).sort({apellido1: 1}).explain("allPlansExecution")
{
        "queryPlanner" : {
                "plannerVersion" : 1,
                "namespace" : "maraton.participantes",
                "indexFilterSet" : false,
                "parsedQuery" : {
                        "apellido1" : {
                                "$eq" : "López"
                        }
                },
                "winningPlan" : {
                        "stage" : "SORT",
                        "sortPattern" : {
                                "apellido1" : 1
                        },
                        "inputStage" : {
                                "stage" : "SORT_KEY_GENERATOR",
                                "inputStage" : {
                                        "stage" : "COLLSCAN",
                                        "filter" : {
                                                "apellido1" : {
                                                        "$eq" : "López"
                                                }
                                        },
                                        "direction" : "forward"
                                }
                        }
                },
                "rejectedPlans" : [ ]
        },
        "executionStats" : {
                "executionSuccess" : true,
                "nReturned" : 0,
                "executionTimeMillis" : 430,
                "totalKeysExamined" : 0,
                "totalDocsExamined" : 1000000,
                "executionStages" : {
                        "stage" : "SORT",
                        "nReturned" : 0,
                        "executionTimeMillisEstimate" : 0,
                        "works" : 1000004,
                        "advanced" : 0,
                        "needTime" : 1000003,
                        "needYield" : 0,
                        "saveState" : 7812,
                        "restoreState" : 7812,
                        "isEOF" : 1,
                        "sortPattern" : {
                                "apellido1" : 1
                        },
                        "memUsage" : 0,
                        "memLimit" : 33554432,
                        "inputStage" : {
                                "stage" : "SORT_KEY_GENERATOR",
                                "nReturned" : 0,
                                "executionTimeMillisEstimate" : 0,
                                "works" : 1000003,
                                "advanced" : 0,
                                "needTime" : 1000002,
                                "needYield" : 0,
                                "saveState" : 7812,
                                "restoreState" : 7812,
                                "isEOF" : 1,
                                "inputStage" : {
                                        "stage" : "COLLSCAN",
                                        "filter" : {
                                                "apellido1" : {
                                                        "$eq" : "López"
                                                }
                                        },
                                        "nReturned" : 0,
                                        "executionTimeMillisEstimate" : 0,
                                        "works" : 1000002,
                                        "advanced" : 0,
                                        "needTime" : 1000001,
                                        "needYield" : 0,
                                        "saveState" : 7812,
                                        "restoreState" : 7812,
                                        "isEOF" : 1,
                                        "direction" : "forward",
                                        "docsExamined" : 1000000
                                }
                        }
                },
                "allPlansExecution" : [ ]
        },
        "serverInfo" : {
                "host" : "G24-EQ09",
                "port" : 27017,
                "version" : "4.2.2",
                "gitVersion" : "a0bbbff6ada159e19298d37946ac8dc4b497eadf"
        },
        "ok" : 1
}
>
```

2. Ordenación con índice simple.

   Si la consulta usa el índice no ordenará en memoria tanto si la ordenación es ascendente o descendente.

```sh
> db.participantes.createIndex({apellido1: 1})
{
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 2,
        "ok" : 1
}
>    

```

Si ejecuto de nuevo la consulta es más rapido

<img src="/images/koda2.png">

<img src="/images/compass2.png">

**CON ESTO NO ORDENAS EN MEMORIA** 

Da lo mismo que la consulta sea ascendente o descendentes, da igual en el sentido de que se aplica el índice, tardan más o menos lo mismo.


3. Ordenación con índice compuesto

   No tendrá que ordenar en memoria si la ordenación usa el mismo sentido de todos los campos del índice o el sentido inverso de todos los campos del índice.
   
   

```sh
> db.participantes.dropIndexes()
{
        "nIndexesWas" : 3,
        "msg" : "non-_id indexes dropped for collection",
        "ok" : 1
}
> db.participantes.createIndex({apellidos1: 1, edad: -1})
{
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 2,
        "ok" : 1
}
>
```

¿Cual es el crierio para usar la ordenación?

Existen 4 casos dos son posibles.

{apellido1: 1, edad: -1} 

No tendrá que ordenar en memoria las operaciones 
 ```sh
 .sort({apellido1: 1, edad: -1})
 .sort({apellido1: -1, edad: 1})
 ```
Si tendrá que ordenar en memoria las operaciones 
 ```sh
 .sort({apellido1: 1, edad: 1})
 .sort({apellido1: 1, edad: 1})
 ```
 
<img src="/images/koda3.png">

<img src="/images/koda4.png">

Lee de arriba abajo o abajo arriba según necesite

<img src="/images/koda5.png">

<img src="/images/koda6.png">
 
Cuando cambia un sentido del orden, si necesita ordenar en memoria.


 
 
 










